// Global variables
var iceCaveEntranceOmniLight;
var iceCaveAmbientLight;
var iceCaveEntrance;

var ambientLightIntensity;

// Enumerations
enum { ICE_CAVE_HOLE_ENTRANCE, ICE_CAVE_MECHANISM_ENTRANCE };

function daggerObject_verb(var objA, var objB)
{
	const DELAY = 30;
	action
	{
		case verbLookAt:
			if (!torchIsLit)
				cutscene (CUTSCENE_TYPE_A)
				{
					Actor_animate(actorIndy, indyCostume_pickUpLow);
					Script_delay(DELAY);
					Actor_talkEgo("OUCH!");
					Script_waitForMessage();
					Actor_talkEgo("It feels sharp!");
					asm { pushWordVar .word objA setObjectName .string "knife?" }
				}
			else
				Actor_talkEgo("That looks like a pretty sharp dagger.");
			break;
		case verbPickUp:
			cutscene (CUTSCENE_TYPE_A)
			{
				Actor_animate(actorIndy, indyCostume_pickUpLow);
				Script_delay(DELAY);
				Object_setState(objA, OBJECT_STATE_DISABLED);
				Actor_pickup(daggerInvObject);
				Actor_animate(actorIndy, indyCostume_stand);
			}
			break;
	}
}

function entranceObject_verb(var objA, var objB)
{
	action
	{
		case verbUse:
			Actor_talkEgo("That's way too high to climb.");
			break;
		case verbTalkTo:
			entranceDialog();
			break;
	}
}

function iceObject_verb(var objA, var objB)
{
	const DELAY = 30;
	action
	{
		case verbLookAt:
			if (!torchIsLit)
				cutscene (CUTSCENE_TYPE_A)
				{
					Actor_animate(actorIndy, indyCostume_pickUpMedium);
					Script_delay(DELAY);
					Actor_talkEgo("Brrr... it's cold.");
				}
			else
			{
				Room_fade(ROOM_FADE_DISSOLVE_EFFECT_1, ROOM_FADE_DISSOLVE_EFFECT_1);
				Room_load(iceCaveMechanismRoom);
			}
			break;
	}
}

function ringObject_verb(var objA, var objB)
{
	const DELAY = 30;
	action
	{
		case verbPickUp:
			cutscene (CUTSCENE_TYPE_A)
			{
				Actor_animate(actorIndy, indyCostume_pickUpLow);
				Script_delay(DELAY);
				Object_setState(objA, OBJECT_STATE_DISABLED);
				Actor_pickup(ringInvObject);
				Actor_animate(actorIndy, indyCostume_stand);
			}
			break;
		case verbLookAt:
			if (!torchIsLit)
			{
				Actor_animate(actorIndy, indyCostume_pickUpLow);
				Script_delay(DELAY);
				Actor_talkEgo("Hmm, that's probably a ring.");
				asm { pushWordVar .word objA setObjectName .string "ring?" }
			}
			else
				Actor_talkEgo("Nice ring.");
			break;
	}
}

function skeletonObject_verb(var objA, var objB)
{
	const DELAY = 30;
	action
	{
		case verbLookAt:
			Actor_talkEgo("Poor guy. I wonder how long he's been lying here.");
			break;
		case verbPickUp:
			if (Object_getOwner(boneInvObject) == VAR_EGO)
				Actor_talkEgo("I already found what I needed.");
			else
				cutscene (CUTSCENE_TYPE_A)
				{
					Actor_talkEgo("Hmmm, I guess this bone could come in handy.");
					Script_waitForMessage();
					Actor_animate(actorIndy, indyCostume_pickUpLow);
					Script_delay(DELAY);
					Actor_pickup(boneInvObject);
					Actor_animate(actorIndy, indyCostume_stand);
				}
			break;
	}
}

function wallObject_verb(var objA, var objB)
{
	const DELAY = 30;
	action
	{
		case verbLookAt:
			if (!torchIsLit)
				cutscene (CUTSCENE_TYPE_A)
				{
					Actor_animate(actorIndy, indyCostume_pickUpMedium);
					Script_delay(DELAY);
					Actor_talkEgo("It feels loose somehow.");
				}
			else
				Actor_talkEgo("It's loose.");
			break;
	}
}

function setupObjects()
{
	// Setup entrance
	Object_setClass(entranceObject, classPerson, 1);
	Object_setState(entranceObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(entranceObject, OBJECT_OWNER_ROOM);

	// Setup wall
	Object_setState(wallObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(wallObject, OBJECT_OWNER_ROOM);

	// Setup ring
	Object_setState(ringObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(ringObject, OBJECT_OWNER_ROOM);

	// Setup icy wall
	Object_setState(iceObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(iceObject, OBJECT_OWNER_ROOM);
	
	// Setup skeleton
	Object_setState(skeletonObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(skeletonObject, OBJECT_OWNER_ROOM);
	
	// Setup dagger
	Object_setState(daggerObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(daggerObject, OBJECT_OWNER_ROOM);
}

thread changeIntensity()
{
	const OMNI_INTENSITY = 255;
	const OMNI_POS_X = 100;
	const OMNI_POS_Y = 40;
	const OMNI_RANGE = 25;
	const AMBIENT_START_INTENSITY = 10;
    const AMBIENT_END_INTENSITY = 55;
	const DELAY = 20;

	// Add omni light
	iceCaveEntranceOmniLight = Light_new(LIGHT_TYPE_OMNI);
	Light_setColor(iceCaveEntranceOmniLight, OMNI_INTENSITY, OMNI_INTENSITY, OMNI_INTENSITY);
	Light_setPos(iceCaveEntranceOmniLight, OMNI_POS_X, OMNI_POS_Y);
	Light_setRange(iceCaveEntranceOmniLight, OMNI_RANGE);

	// Add ambient light
	iceCaveAmbientLight = Light_new(LIGHT_TYPE_AMBIENT);

	// Add areas
	Light_addArea(0, darkArea_start, darkArea_end);
	Light_addArea(0, ringObjectArea_start, ringObjectArea_end);
	Light_addArea(actorIndy, indyCostumeArea_start, indyCostumeArea_end);

	// Gradually brighten the ambient light
	for (ambientLightIntensity = AMBIENT_START_INTENSITY; ambientLightIntensity < AMBIENT_END_INTENSITY; ambientLightIntensity++)
	{
		// Terminate the function if torch is lit already
		if (torchIsLit)
			return;

		Light_setColor(iceCaveAmbientLight, ambientLightIntensity, ambientLightIntensity, ambientLightIntensity);
		Script_delay(DELAY);
	}
}

thread lightning()
{
	var lightningLight;
	var random;

	lightningLight = Light_new(LIGHT_TYPE_AMBIENT);
	Light_setColor(lightningLight, 0, 0, 0);

	while (1)
	{
		Light_setColor(lightningLight, 0, 0, 0);
		if (Util_getRandomNumber(50) == 0)
		{
			Light_setColor(lightningLight, 255, 255, 255);
			Util_printDebug("%V{thunderstrike}");
			ambientLightIntensity = 10;
		}
		Script_break();
	}
}

thread mousePos()
{
	// Setup print line charset
	Interface_setCharset(font2);
	Interface_printLineLoadDefault();
	Interface_printLineColor(COLOR_PERSIMMON);
	Interface_printLineCenter();
	Interface_printLineOverhead();
	Interface_printLineSaveDefault();

	// Loop indefinitely
	while (1)
	{
		Interface_printLineAt(150, 10);
     	Interface_printLine("X: %i{VAR_MOUSE_X} Y: %i{VAR_MOUSE_Y}");
		Script_break();
	}
}

function entranceDialog()
{
	const LINE_TORCH = 0;
	const LINE_LEAVE = 1;

	var dialog;
	var selection;

	// Setup dialogs first
	dialog = Dialog_new();
	Dialog_addLine(dialog, "Send me the torch!"); // LINE_TORCH
	Dialog_addLine(dialog, "I'll talk to you later."); // LINE_LEAVE

	// Remove torch line if necessary
	if (Object_getOwner(unlitTorchInvObject) == VAR_EGO)
		Dialog_removeLine(dialog, LINE_TORCH);

	// Talk to Harald
	cutscene (CUTSCENE_TYPE_B)
	{
		Actor_talkEgo("Harald?");
		Script_waitForMessage();
	}

	// Disable inventory
	Inventory_hide();
	Inventory_disable();
	Script_break();

	// Enable dialog area
	Dialog_enable();

	do
	{
		// Show our dialog lines
		Dialog_show(dialog);

		// Wait for a line selection
		selection = Dialog_waitForSelection(dialog);
		switch (selection)
		{
			case LINE_TORCH:
				// Get torch
				Script_delaySeconds(1);
				Actor_pickup(unlitTorchInvObject);
				Actor_talkEgo("Thanks!");
				Script_waitForMessage();
				Dialog_removeLine(dialog, LINE_TORCH);
				break;
			case LINE_LEAVE:
				Actor_setDirection(ACTOR_DIR_SOUTH);
				break;
		}
	}
	while (selection != LINE_LEAVE);

	// Delete dialog lines
	Dialog_delete(dialog);

	// Disable dialog area
	Dialog_disable();

	// Re-enable Inventory
	Inventory_enable();
	Inventory_show();
}

function iceCaveRoom_entry()
{
	const START_X = 96;
	const START_Y = 48;

	// Launch lightning thread
	lightning();
	
	if (!torchIsLit)
	{
		// Change room insensity slowly as soon as we enter the room
		changeIntensity();
	
		// Setup object states, classes and owners
		setupObjects();
	
		// Set Indy as the default actor
		VAR_EGO = actorIndy;

		// Position Indy
		Actor_putAtXY(actorIndy, START_X, START_Y, VAR_ROOM);
		Actor_setDirection(ACTOR_DIR_SOUTH);

		// Give default items to Indy
		Actor_pickup(whipInvObject);
		Actor_pickup(matchesInvObject);

		// Set inventory touch mode and enable inventory and input
		Inventory_setTouchVerb(1);
		Inventory_enable();
		Inventory_show();
		Input_enable();
	
		// TODO: Fall down and stand up animation *OUCH*
		Interface_printLineLoadDefault();
		Interface_printLineColor(COLOR_DODGER_BLUE);
		Interface_printLineAt(20, 3);
		Interface_printLineLeft();
		Interface_printLine("Everything alright Indy?");
		Script_waitForMessage();
		Actor_talkEgo("It's ok.");
		Script_waitForMessage();
	}
}
