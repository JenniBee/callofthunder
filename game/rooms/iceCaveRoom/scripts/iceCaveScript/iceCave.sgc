// Enumerations
enum { PUZZLE_LIGHT_ROOM_START, PUZZLE_LIGHT_ROOM_GOT_TORCH, PUZZLE_LIGHT_ROOM_SOLVED };

// Global variables
var puzzleLightRoom;

function daggerObject_verb(var objA, var objB)
{
	action
	{
		case verbLookAt:
			//Actor_animate(actorIndy, );
			Actor_printEgo("OUCH!");
			Script_waitForMessage();
			Actor_printEgo("That's a very sharp dagger!");
			Script_waitForMessage();
			asm { pushWordVar .word objA setObjectName .string "dagger" }
			break;
		case verbPickUp:
			Actor_pickup(daggerInvObject);
			Object_setState(objA, OBJECT_STATE_DISABLED);
			break;
	}
}

function entranceObject_verb(var objA, var objB)
{
	action
	{
		case verbUse:
			Actor_talkEgo("That's way too high to climb.");
			break;
		case verbTalkTo:
			entranceDialog();
			break;
	}
}

function iceObject_verb(var objA, var objB)
{
	action
	{
		case verbLookAt:
			if (puzzleLightRoom != PUZZLE_LIGHT_ROOM_SOLVED)
				Actor_talkEgo("Brrr... it's cold.");
			else
				Room_load(iceCaveMechanismRoom);
			break;
	}
}

function ringObject_verb(var objA, var objB)
{
	action
	{
		case verbPickUp:
			Actor_pickup(ringInvObject);
			Object_setState(objA, OBJECT_STATE_DISABLED);
			break;
		case verbLookAt:
			Actor_talkEgo("Hmm, that's probably a ring.");
			Script_waitForMessage();
			asm { pushWordVar .word objA setObjectName .string "ring?" }
			break;
	}
}

function skeletonObject_verb(var objA, var objB)
{
	action
	{
		case verbLookAt:
			Actor_talkEgo("Poor guy. I wonder how long he's been lying here.");
			break;
		case verbPickUp:
			Actor_talkEgo("I think I could use the fibula.");
			Script_waitForMessage();
			Actor_pickup(boneInvObject);
			break;
	}
}

function wallObject_verb(var objA, var objB)
{
	action
	{
		case verbLookAt:
			//Actor_animate(actorIndy, );
			Actor_printEgo("It feels loose somehow.");
			break;
	}
}

function setupObjects()
{
	// Setup entrance
	Object_setClass(entranceObject, classPerson, 1);
	Object_setState(entranceObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(entranceObject, OBJECT_OWNER_ROOM);

	// Setup wall
	Object_setState(wallObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(wallObject, OBJECT_OWNER_ROOM);

	// Setup ring
	Object_setState(ringObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(ringObject, OBJECT_OWNER_ROOM);

	// Setup icy wall
	Object_setState(iceObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(iceObject, OBJECT_OWNER_ROOM);
	
	// Setup skeleton
	Object_setState(skeletonObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(skeletonObject, OBJECT_OWNER_ROOM);
	
	// Setup dagger
	Object_setState(daggerObject, OBJECT_STATE_PICKABLE);
	Object_setOwner(daggerObject, OBJECT_OWNER_ROOM);
}

function setupPuzzles()
{
	// Set default puzzle states
	puzzleLightRoom = PUZZLE_LIGHT_ROOM_START;
}

thread changeIntensity()
{
	const OMNI_INTENSITY = 255;
	const OMNI_POS_X = 100;
	const OMNI_POS_Y = 40;
	const OMNI_RANGE = 25;
	const AMBIENT_MIN_INTENSITY = 10;
    const AMBIENT_MEDIUM_INTENSITY = 55;
	const AMBIENT_MAX_INTENSITY = 255;
	const DELAY = 20;
	const AMBIENT_INTENSITY_STEP = 40;
    var i;
	var omniLight;
	var ambientLight;

	// Add omni light
	omniLight = Light_new(LIGHT_TYPE_OMNI);
	Light_setColor(omniLight, OMNI_INTENSITY, OMNI_INTENSITY, OMNI_INTENSITY);
	Light_setPos(omniLight, OMNI_POS_X, OMNI_POS_Y);
	Light_setRange(omniLight, OMNI_RANGE);

	// Add ambient light
	ambientLight = Light_new(LIGHT_TYPE_AMBIENT);

	// Add areas
	Light_addArea(0, darkArea_start, darkArea_end);
	Light_addArea(0, ringObjectArea_start, ringObjectArea_end);
	Light_addArea(actorIndy, indyCostumeArea_start, indyCostumeArea_end);

	// Gradually brighten the ambient light
    for (i = AMBIENT_MIN_INTENSITY; i < AMBIENT_MEDIUM_INTENSITY; i++)
	{
    	Light_setColor(ambientLight, i, i, i);
		Script_delay(DELAY);
	}

	// Wait for the torch puzzle to be solved
	while (puzzleLightRoom != PUZZLE_LIGHT_ROOM_SOLVED)
		Script_break();

	// Remove omni light
	Light_delete(omniLight);

	// Brighten the room completely
	for (i = AMBIENT_MEDIUM_INTENSITY; i < AMBIENT_MAX_INTENSITY; i += AMBIENT_INTENSITY_STEP)
    {
		Light_setColor(ambientLight, i, i, i);
        Script_break();
    }

	// Disable inventory touch mode
	Inventory_setTouchVerb(0);
	Inventory_show();
}

thread mousePos()
{
	// Setup print line charset
	Interface_setCharset(font2);
	Interface_printLineLoadDefault();
	Interface_printLineColor(COLOR_PERSIMMON);
	Interface_printLineCenter();
	Interface_printLineOverhead();
	Interface_printLineSaveDefault();

	// Loop indefinitely
	while (1)
	{
		Interface_printLineAt(150, 10);
     	Interface_printLine("X: %i{VAR_MOUSE_X} Y: %i{VAR_MOUSE_Y}");
		Script_break();
	}
}

function entranceDialog()
{
	const LINE_TORCH = 0;
	const LINE_LEAVE = 1;

	var dialog;
	var selection;

	// Setup dialogs first
	dialog = Dialog_new();
	Dialog_addLine(dialog, "Send me the torch!"); // LINE_TORCH
	Dialog_addLine(dialog, "I'll talk to you later."); // LINE_LEAVE

	// Remove torch line if necessary
	if (puzzleLightRoom >= PUZZLE_LIGHT_ROOM_GOT_TORCH)
		Dialog_removeLine(dialog, LINE_TORCH);

	// Talk to Harald
	cutscene ()
	{
		Actor_talkEgo("Harald?");
		Script_waitForMessage();
	}

	// Enable dialog area
	Dialog_enable();

	// Show our dialog lines
	Dialog_show(dialog);

	// Wait for a line selection
	selection = Dialog_waitForSelection(dialog);
	switch (selection)
	{
		case LINE_TORCH:
			// Get torch
			Script_delaySeconds(1);
			Actor_pickup(unlitTorchInvObject);
			Actor_talkEgo("Thanks!");
			Script_waitForMessage();

			// Update puzzle state
			puzzleLightRoom = PUZZLE_LIGHT_ROOM_GOT_TORCH;
			break;
		case LINE_LEAVE:
			Actor_setDirection(ACTOR_DIR_SOUTH);
			break;
	}

	// Delete dialog lines
	Dialog_delete(dialog);

	// Disable dialog area
	Dialog_disable();
}

function entry()
{
	const START_X = 96;
	const START_Y = 48;

	// Change room insensity slowly as soon as we enter the room
	changeIntensity();

	//mousePos();
	
	// Setup logic
	setupObjects();
	setupPuzzles();
	
	// Set Indy as the default actor
	VAR_EGO = actorIndy;

	// Position Indy
	Actor_putAtXY(actorIndy, START_X, START_Y, VAR_ROOM);
	Actor_setDirection(ACTOR_DIR_SOUTH);

	// Give default items to Indy
	Actor_pickup(whipInvObject);
	Actor_pickup(matchesInvObject);

	// Set inventory touch mode and enable inventory and input
	Inventory_setTouchVerb(1);
	Inventory_enable();
	Input_enable();
	
	// TODO: Fall down and stand up animation *OUCH*
	// Actor from surface: "Everything's alright Indy?"
	Actor_talkEgo("It's ok.");
	Script_waitForMessage();
	// Small dialog -> torch falls down
}

function exit()
{
}
